#!/usr/bin/env python3
"""Simple Tkinter GUI to filter an SRT file using backend subtitle filtering logic.

Features:
- Pick an .srt file with a file dialog
- Choose CEFR level (A1, A2, B1, B2)
- Run the same filtering pipeline as the backend (spaCy proper-name detection,
  non-vocabulary filtering, user-level difficulty filtering)
- Save a filtered SRT next to the original ("*_filtered.srt")
"""

import asyncio
import sys
import tkinter as tk
from pathlib import Path
from tkinter import filedialog, messagebox

# Ensure backend root is on sys.path so we can import services and api modules
BACKEND_DIR = Path(__file__).resolve().parent.parent
if str(BACKEND_DIR) not in sys.path:
    sys.path.insert(0, str(BACKEND_DIR))

# On Windows, use Proactor event loop policy (matches run_backend.py behavior)
if sys.platform == "win32":  # pragma: no cover - platform specific
    try:
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    except Exception:
        pass

from api.routes.filtering_routes import _save_filtered_subtitles_to_file
from services.filterservice.direct_subtitle_processor import DirectSubtitleProcessor

DEFAULT_LANGUAGE = "de"
DEFAULT_USER_ID = 1
VALID_LEVELS = ["A1", "A2", "B1", "B2"]


async def _run_filtering(srt_path: str, level: str) -> dict:
    """Run backend filtering pipeline for a single SRT file.

    Returns a dict with:
        - output_path: path to filtered SRT file
        - statistics: filtering statistics
        - learning_count: number of subtitles kept for learning
        - empty_count: number of subtitles filtered out
        - total_count: total number of subtitles
    """
    processor = DirectSubtitleProcessor()

    result = await processor.process_srt_file(
        srt_file_path=srt_path,
        user_id=str(DEFAULT_USER_ID),
        user_level=level,
        language=DEFAULT_LANGUAGE,
    )

    if not result or "learning_subtitles" not in result:
        raise RuntimeError("No learning subtitles generated by backend processor")

    output_path = str(srt_path).replace(".srt", "_filtered.srt")
    # Save only learning subtitles (those with words above user level)
    # This filters out subtitles where user understands all words
    await _save_filtered_subtitles_to_file(result["learning_subtitles"], output_path)

    # Extract statistics
    learning_count = len(result.get("learning_subtitles", []))
    empty_count = len(result.get("empty_subtitles", []))
    total_count = learning_count + empty_count
    statistics = result.get("statistics", {})

    return {
        "output_path": output_path,
        "statistics": statistics,
        "learning_count": learning_count,
        "empty_count": empty_count,
        "total_count": total_count,
    }


def _run_filtering_sync(srt_path: str, level: str) -> dict:
    """Synchronous wrapper around the async filtering function."""
    return asyncio.run(_run_filtering(srt_path, level))


class SRTFilterApp:
    def __init__(self) -> None:
        self.root = tk.Tk()
        self.root.title("LangPlug SRT Filter")
        self.root.geometry("480x200")

        self.selected_file_var = tk.StringVar(value="")
        self.level_var = tk.StringVar(value=VALID_LEVELS[0])

        self._build_ui()

    def _build_ui(self) -> None:
        padding = {"padx": 10, "pady": 10}

        file_frame = tk.Frame(self.root)
        file_frame.pack(fill="x", **padding)

        tk.Label(file_frame, text="SRT file:").pack(side="left")

        entry = tk.Entry(file_frame, textvariable=self.selected_file_var, width=50)
        entry.pack(side="left", padx=(5, 5))

        browse_btn = tk.Button(file_frame, text="Browse...", command=self._on_browse)
        browse_btn.pack(side="left")

        level_frame = tk.Frame(self.root)
        level_frame.pack(fill="x", **padding)

        tk.Label(level_frame, text="Language level:").pack(side="left")

        level_menu = tk.OptionMenu(level_frame, self.level_var, *VALID_LEVELS)
        level_menu.pack(side="left", padx=(5, 0))

        action_frame = tk.Frame(self.root)
        action_frame.pack(fill="x", **padding)

        run_btn = tk.Button(action_frame, text="Filter subtitles", command=self._on_run)
        run_btn.pack(side="left")

    def _on_browse(self) -> None:
        path = filedialog.askopenfilename(
            title="Select SRT file",
            filetypes=[("SRT files", "*.srt"), ("All files", "*.*")],
        )
        if path:
            self.selected_file_var.set(path)

    def _on_run(self) -> None:
        srt_path = self.selected_file_var.get().strip()
        level = self.level_var.get().strip().upper()

        if not srt_path:
            messagebox.showerror("Error", "Please select an SRT file first.")
            return

        if level not in VALID_LEVELS:
            messagebox.showerror("Error", f"Invalid level '{level}'. Choose one of: {', '.join(VALID_LEVELS)}")
            return

        try:
            result = _run_filtering_sync(srt_path, level)

            # Format statistics for display
            total = result["total_count"]
            kept = result["learning_count"]
            filtered = result["empty_count"]
            kept_pct = (kept / total * 100) if total > 0 else 0
            filtered_pct = (filtered / total * 100) if total > 0 else 0

            message = (
                f"Filtering complete!\n\n"
                f"SUMMARY (Level: {level}):\n"
                f"  Total subtitles: {total}\n"
                f"  Kept (for learning): {kept} ({kept_pct:.1f}%)\n"
                f"  Filtered out (understood): {filtered} ({filtered_pct:.1f}%)\n\n"
                f"Output saved to:\n{result['output_path']}"
            )

            messagebox.showinfo("Success", message)
        except Exception as exc:  # pragma: no cover - GUI error path
            messagebox.showerror("Filtering failed", str(exc))

    def run(self) -> None:
        self.root.mainloop()


def main() -> None:
    app = SRTFilterApp()
    app.run()


if __name__ == "__main__":
    main()
