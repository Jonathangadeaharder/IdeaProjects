#!/usr/bin/env python3
"""Simple Tkinter GUI to filter an SRT file using backend subtitle filtering logic.

Features:
- Pick an .srt file with a file dialog
- Choose CEFR level (A1, A2, B1, B2)
- Run the same filtering pipeline as the backend (spaCy proper-name detection,
  non-vocabulary filtering, user-level difficulty filtering)
- Save a filtered SRT next to the original ("*_filtered.srt")
"""

import asyncio
import sys
from pathlib import Path
import tkinter as tk
from tkinter import filedialog, messagebox

# Ensure backend root is on sys.path so we can import services and api modules
BACKEND_DIR = Path(__file__).resolve().parent.parent
if str(BACKEND_DIR) not in sys.path:
    sys.path.insert(0, str(BACKEND_DIR))

# On Windows, use Proactor event loop policy (matches run_backend.py behavior)
if sys.platform == "win32":  # pragma: no cover - platform specific
    try:
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    except Exception:
        pass

from services.filterservice.direct_subtitle_processor import DirectSubtitleProcessor
from api.routes.filtering_routes import _save_filtered_subtitles_to_file


DEFAULT_LANGUAGE = "de"
DEFAULT_USER_ID = 1
VALID_LEVELS = ["A1", "A2", "B1", "B2"]


async def _run_filtering(srt_path: str, level: str) -> str:
    """Run backend filtering pipeline for a single SRT file.

    Returns the path to the filtered SRT file.
    """
    processor = DirectSubtitleProcessor()

    result = await processor.process_srt_file(
        srt_file_path=srt_path,
        user_id=str(DEFAULT_USER_ID),
        user_level=level,
        language=DEFAULT_LANGUAGE,
    )

    if not result or "filtered_subtitles" not in result:
        raise RuntimeError("No filtered subtitles generated by backend processor")

    output_path = str(srt_path).replace(".srt", "_filtered.srt")
    await _save_filtered_subtitles_to_file(result["filtered_subtitles"], output_path)
    return output_path


def _run_filtering_sync(srt_path: str, level: str) -> str:
    """Synchronous wrapper around the async filtering function."""
    return asyncio.run(_run_filtering(srt_path, level))


class SRTFilterApp:
    def __init__(self) -> None:
        self.root = tk.Tk()
        self.root.title("LangPlug SRT Filter")
        self.root.geometry("480x200")

        self.selected_file_var = tk.StringVar(value="")
        self.level_var = tk.StringVar(value=VALID_LEVELS[0])

        self._build_ui()

    def _build_ui(self) -> None:
        padding = {"padx": 10, "pady": 10}

        file_frame = tk.Frame(self.root)
        file_frame.pack(fill="x", **padding)

        tk.Label(file_frame, text="SRT file:").pack(side="left")

        entry = tk.Entry(file_frame, textvariable=self.selected_file_var, width=50)
        entry.pack(side="left", padx=(5, 5))

        browse_btn = tk.Button(file_frame, text="Browse...", command=self._on_browse)
        browse_btn.pack(side="left")

        level_frame = tk.Frame(self.root)
        level_frame.pack(fill="x", **padding)

        tk.Label(level_frame, text="Language level:").pack(side="left")

        level_menu = tk.OptionMenu(level_frame, self.level_var, *VALID_LEVELS)
        level_menu.pack(side="left", padx=(5, 0))

        action_frame = tk.Frame(self.root)
        action_frame.pack(fill="x", **padding)

        run_btn = tk.Button(action_frame, text="Filter subtitles", command=self._on_run)
        run_btn.pack(side="left")

    def _on_browse(self) -> None:
        path = filedialog.askopenfilename(
            title="Select SRT file",
            filetypes=[("SRT files", "*.srt"), ("All files", "*.*")],
        )
        if path:
            self.selected_file_var.set(path)

    def _on_run(self) -> None:
        srt_path = self.selected_file_var.get().strip()
        level = self.level_var.get().strip().upper()

        if not srt_path:
            messagebox.showerror("Error", "Please select an SRT file first.")
            return

        if level not in VALID_LEVELS:
            messagebox.showerror("Error", f"Invalid level '{level}'. Choose one of: {', '.join(VALID_LEVELS)}")
            return

        try:
            output_path = _run_filtering_sync(srt_path, level)
            messagebox.showinfo(
                "Success",
                f"Filtered subtitles saved to:\n{output_path}",
            )
        except Exception as exc:  # pragma: no cover - GUI error path
            messagebox.showerror("Filtering failed", str(exc))

    def run(self) -> None:
        self.root.mainloop()


def main() -> None:
    app = SRTFilterApp()
    app.run()


if __name__ == "__main__":
    main()
